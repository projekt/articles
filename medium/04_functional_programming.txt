<!-- Original article: https://projekt.github.io/articles/ -->
<div style="background: #f0f0f0; padding: 15px; border-left: 4px solid #333; margin-bottom: 30px;">
<p><strong>Note:</strong> This article was originally published on my website. For the latest version and more articles, visit <a href="https://projekt.github.io/articles/">https://projekt.github.io/articles/</a></p>
</div>

<h1 id="programming-paradigms-series-article-4-functional-programming">Programming Paradigms Series - Article 4: Functional Programming</h1>
<p><strong>â±ï¸ 7-Minute Read</strong></p>
<p><strong>Series Navigation:</strong> <a href="03_oop.md">â† Object-Oriented Programming</a> | Article 4 of 7 | Next: <a href="05_declarative_programming.md">Declarative Programming â†’</a></p>
<hr />
<p><strong>About This Series</strong></p>
<p>This article series represents my journey of learning and applying fundamental programming concepts to the Dart programming language. These are my detailed notes and insights from the learning process, which I hope will be valuable to others exploring similar topics.</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#concept">Concept</a></li>
<li><a href="#real-life-analogy">Real-Life Analogy</a></li>
<li><a href="#dart-example">Dart Example</a></li>
<li><a href="#functional-programming-pipeline">Functional Programming Pipeline</a></li>
<li><a href="#pure-vs-impure-functions">Pure vs Impure Functions</a></li>
<li><a href="#immutability-concept">Immutability Concept</a></li>
<li><a href="#higher-order-functions">Higher-Order Functions</a></li>
</ol>
<hr />
<h2 id="concept">Concept</h2>
<p>Functional programming treats computation as the evaluation of mathematical functions. It emphasizes immutability (data that doesn't change) and avoids side effects (changes to state outside the function).</p>
<h2 id="real-life-analogy">Real-Life Analogy</h2>
<p>Think of a vending machine for drinks. You put in money and a selection code, and you get a drink out. The machine doesn't remember your previous purchases or change its behavior based on past interactions. Each transaction is independent:
- <strong>Input</strong>: money + selection
- <strong>Output</strong>: drink
- <strong>No side effects</strong>: The machine's core function doesn't change based on history</p>
<h2 id="dart-example">Dart Example</h2>
<pre class="codehilite"><code class="language-dart">void main() {
  // Functional approach to calculate sum of squares
  List&lt;int&gt; numbers = [1, 2, 3, 4, 5];

  // Using functional methods: map and reduce
  int sum = numbers
      .map((n) =&gt; n * n)           // Transform each number to its square
      .reduce((a, b) =&gt; a + b);    // Combine all squares into sum

  print('Sum of squares: $sum');   // Output: 55

  // Pure function example
  int multiply(int a, int b) {
    return a * b;  // Always returns same output for same input
  }

  // Higher-order function (function that takes functions as parameters)
  List&lt;int&gt; applyOperation(List&lt;int&gt; numbers, int Function(int) operation) {
    return numbers.map(operation).toList();
  }

  List&lt;int&gt; doubled = applyOperation(numbers, (n) =&gt; n * 2);
  print('Doubled: $doubled');  // [2, 4, 6, 8, 10]

  // Immutability example
  final originalList = [1, 2, 3];
  final newList = [...originalList, 4];  // Create new list instead of modifying

  print('Original: $originalList');  // [1, 2, 3] - unchanged
  print('New: $newList');            // [1, 2, 3, 4]
}

// Pure function - no side effects
int calculateDiscount(int price, double discountRate) {
  return (price * (1 - discountRate)).round();
}

// Impure function - has side effects (modifies external state)
int counter = 0;
void incrementCounter() {
  counter++;  // Side effect: modifies external variable
}
</code></pre>

<h2 id="functional-programming-pipeline">Functional Programming Pipeline</h2>
<pre class="codehilite"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         ğŸ§® FUNCTIONAL TRANSFORMATION PIPELINE ğŸ§®         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Input Data: [1, 2, 3, 4, 5] ğŸ“¥
     â”‚
     â”‚ map(n =&gt; nÂ²)
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ”„ TRANSFORM       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  [1, 4, 9, 16, 25]  â”‚  â† Each element squared
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ reduce((a, b) =&gt; a + b)
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â• AGGREGATE       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  1 + 4 = 5          â”‚
â”‚  5 + 9 = 14         â”‚
â”‚  14 + 16 = 30       â”‚
â”‚  30 + 25 = 55       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
    Result: 55 âœ¨ ğŸ“¤

ğŸ¯ Pure functions â†’ Predictable results â†’ No side effects
</code></pre>

<h2 id="pure-vs-impure-functions">Pure vs Impure Functions</h2>
<pre class="codehilite"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                  âœ… PURE FUNCTION âœ…                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                               â•‘
â•‘  int add(int a, int b) {                                      â•‘
â•‘    return a + b;     // Same input â†’ Same output âœ“           â•‘
â•‘  }                   // No side effects âœ“                    â•‘
â•‘                                                               â•‘
â•‘  ğŸ“Š Properties:                                               â•‘
â•‘  âœ“ Deterministic (100% predictable)                          â•‘
â•‘  âœ“ No side effects (doesn't change external state)           â•‘
â•‘  âœ“ Easy to test (input â†’ output, that's it!)                â•‘
â•‘  âœ“ Can be cached (memoization works perfectly)               â•‘
â•‘  âœ“ Thread-safe (parallel execution friendly)                 â•‘
â•‘                                                               â•‘
â•‘  Example: add(2, 3) ALWAYS returns 5                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                  âŒ IMPURE FUNCTION âŒ                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                               â•‘
â•‘  int counter = 0;                                             â•‘
â•‘  void increment() {                                           â•‘
â•‘    counter++;        // Modifies external state âœ—            â•‘
â•‘    print(counter);   // Has side effect (I/O) âœ—             â•‘
â•‘  }                                                            â•‘
â•‘                                                               â•‘
â•‘  âš ï¸ Issues:                                                   â•‘
â•‘  âœ— Unpredictable results (depends on external state)         â•‘
â•‘  âœ— Hard to test (need to set up external state)             â•‘
â•‘  âœ— Can cause bugs in concurrent code (race conditions)       â•‘
â•‘  âœ— Difficult to reason about (hidden dependencies)           â•‘
â•‘  âœ— Cannot be safely cached                                   â•‘
â•‘                                                               â•‘
â•‘  Example: increment() returns different values each time      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</code></pre>

<h2 id="immutability-concept">Immutability Concept</h2>
<pre class="codehilite"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ğŸ”„ MUTABLE vs ğŸ”’ IMMUTABLE ğŸ”’                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”´ Mutable Approach (Imperative):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ List: [1, 2, 3]  â”‚ â† Original object
â”‚ Memory: 0x1000   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ .add(4)  â† Modifies in place
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ List: [1,2,3,4]  â”‚ â† Same object, changed! âš ï¸
â”‚ Memory: 0x1000   â”‚ â† Same memory address
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Problem: Other references are affected!
   If someone else had a reference to this list,
   they'll see the change unexpectedly.

ğŸŸ¢ Immutable Approach (Functional):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ List: [1, 2, 3]  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Still [1, 2, 3] âœ“
â”‚ Memory: 0x1000   â”‚            Original unchanged!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ [...list, 4]  â† Creates new
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ New: [1,2,3,4]   â”‚ â† New object created âœ“
â”‚ Memory: 0x2000   â”‚ â† Different memory address
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ… Benefit: Predictable, safe, no surprises!
   Original data is preserved, easier to reason about.
</code></pre>

<h2 id="higher-order-functions">Higher-Order Functions</h2>
<pre class="codehilite"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            ğŸ¯ HIGHER-ORDER FUNCTIONS ğŸ¯                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

A Higher-Order Function is a function that:
  1ï¸âƒ£ Takes functions as parameters, OR
  2ï¸âƒ£ Returns a function as a result

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Higher-Order Function Example                   â”‚
â”‚                                                          â”‚
â”‚  applyOperation(numbers, operation)                      â”‚
â”‚         â”‚              â”‚                                 â”‚
â”‚    ğŸ“¦ Data         ğŸ”§ Function                           â”‚
â”‚    to process      to apply                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚               â”‚
          â–¼               â–¼
    [1,2,3,4,5]      (n) =&gt; n * 2
          â”‚               â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  ğŸ”„ Apply to  â”‚
          â”‚  all elements â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
         [2, 4, 6, 8, 10] âœ¨

Benefits:
âœ“ Code reusability (same function, different operations)
âœ“ Abstraction (separate &quot;what to do&quot; from &quot;how to do it&quot;)
âœ“ Composability (combine functions to build complex logic)

Example operations you can pass:
â€¢ (n) =&gt; n * 2        (double)
â€¢ (n) =&gt; n * n        (square)
â€¢ (n) =&gt; n + 10       (add 10)
</code></pre>

<p>Functional programming shines in data processing and transformation tasks. Its emphasis on pure functions and immutability makes code more predictable, testable, and suitable for parallel execution.</p>
<hr />
<h2 id="further-reading">Further Reading</h2>
<p><strong>Functional Programming:</strong>
- <a href="https://dart.dev/guides/language/effective-dart/usage#prefer-using-higher-order-methods">Functional Programming in Dart</a> - Official guidelines
- <a href="https://www.freecodecamp.org/news/functional-programming-principles-in-javascript-1b8fc6c3563f/">Functional Programming Principles</a> - Core concepts
- <a href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">Why Functional Programming Matters</a> - Classic paper</p>
<p><strong>Dart Functional Features:</strong>
- <a href="https://dart.dev/codelabs/iterables">Iterable Collections</a> - map, where, reduce
- <a href="https://dart.dev/guides/language/language-tour#functions">Functions in Dart</a> - First-class functions</p>
<p><strong>Advanced Topics:</strong>
- <a href="https://www.sitepoint.com/immutability-javascript/">Immutability in Practice</a> - Benefits and techniques
- <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0">Function Composition</a> - Building complex functions</p>
<p><strong>Books:</strong>
- <a href="https://www.manning.com/books/functional-programming-in-javascript">Functional Programming in JavaScript</a> - Practical approach
- <a href="https://mostly-adequate.gitbook.io/mostly-adequate-guide/">Professor Frisby's Mostly Adequate Guide to FP</a> - Free online book</p>
<hr />
<h2 id="about-the-author">ğŸ‘¤ About the Author</h2>
<p><strong>SrÄ‘an LjuÅ¡tina</strong> - Software Developer &amp; Technical Writer</p>
<p>ğŸŒ <a href="https://srdapp.rs">Website</a> | ğŸ’¼ <a href="https://www.linkedin.com/in/srdjanljustina/">LinkedIn</a> | ğŸ’» <a href="https://github.com/projekt">GitHub</a></p>
<hr />
<p><strong>Series Navigation:</strong> <a href="03_oop.md">â† Object-Oriented Programming</a> | Article 4 of 7 | Next: <a href="05_declarative_programming.md">Declarative Programming â†’</a></p>
<p><strong>Other Articles in This Series:</strong>
- <a href="01_what_are_programming_paradigms.md">Article 1: What Are Programming Paradigms?</a>
- <a href="02_imperative_programming.md">Article 2: Imperative Programming</a>
- <a href="03_oop.md">Article 3: Object-Oriented Programming (OOP)</a>
- <strong>Article 4: Functional Programming</strong> (Current)
- <a href="05_declarative_programming.md">Article 5: Declarative Programming</a>
- <a href="06_procedural_programming.md">Article 6: Procedural Programming</a>
- <a href="07_summary.md">Article 7: Choosing the Right Paradigm - Summary and Best Practices</a></p>