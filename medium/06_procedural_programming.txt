<!-- Original article: https://projekt.github.io/articles/ -->
<div style="background: #f0f0f0; padding: 15px; border-left: 4px solid #333; margin-bottom: 30px;">
<p><strong>Note:</strong> This article was originally published on my website. For the latest version and more articles, visit <a href="https://projekt.github.io/articles/">https://projekt.github.io/articles/</a></p>
</div>

<h1 id="programming-paradigms-series-article-6-procedural-programming">Programming Paradigms Series - Article 6: Procedural Programming</h1>
<p><strong>â±ï¸ 6-Minute Read</strong></p>
<p><strong>Series Navigation:</strong> <a href="05_declarative_programming.md">â† Declarative Programming</a> | Article 6 of 7 | Next: <a href="07_summary.md">Summary and Best Practices â†’</a></p>
<hr />
<p><strong>About This Series</strong></p>
<p>This article series represents my journey of learning and applying fundamental programming concepts to the Dart programming language. These are my detailed notes and insights from the learning process, which I hope will be valuable to others exploring similar topics.</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#concept">Concept</a></li>
<li><a href="#real-life-analogy">Real-Life Analogy</a></li>
<li><a href="#dart-example">Dart Example</a></li>
<li><a href="#procedural-programming-flow">Procedural Programming Flow</a></li>
<li><a href="#procedural-vs-oop-comparison">Procedural vs OOP Comparison</a></li>
</ol>
<hr />
<h2 id="concept">Concept</h2>
<p>Procedural programming is a subset of imperative programming where you organize code into procedures (functions) that operate on data. It emphasizes a step-by-step approach but with reusable blocks of code.</p>
<h2 id="real-life-analogy">Real-Life Analogy</h2>
<p>Think of an assembly line in a factory. Each station (procedure) performs a specific task:
- Station 1: Cut metal
- Station 2: Bend metal
- Station 3: Weld parts
- Station 4: Paint product
- Station 5: Package</p>
<p>Each station is independent but contributes to the final product.</p>
<h2 id="dart-example">Dart Example</h2>
<pre class="codehilite"><code class="language-dart">// Procedural approach to processing student grades

void main() {
  List&lt;int&gt; grades = [85, 92, 78, 95, 88, 73, 90];

  displayGrades(grades);
  double avg = calculateAverage(grades);
  print('\nAverage grade: ${avg.toStringAsFixed(2)}');

  int highest = findHighest(grades);
  int lowest = findLowest(grades);
  print('Highest: $highest, Lowest: $lowest');

  String letterGrade = getLetterGrade(avg);
  print('Class average letter grade: $letterGrade');
}

// Procedure 1: Display all grades
void displayGrades(List&lt;int&gt; grades) {
  print('Student Grades:');
  for (int i = 0; i &lt; grades.length; i++) {
    print('Student ${i + 1}: ${grades[i]}');
  }
}

// Procedure 2: Calculate average
double calculateAverage(List&lt;int&gt; grades) {
  int sum = 0;
  for (int grade in grades) {
    sum += grade;
  }
  return sum / grades.length;
}

// Procedure 3: Find highest grade
int findHighest(List&lt;int&gt; grades) {
  int highest = grades[0];
  for (int grade in grades) {
    if (grade &gt; highest) {
      highest = grade;
    }
  }
  return highest;
}

// Procedure 4: Find lowest grade
int findLowest(List&lt;int&gt; grades) {
  int lowest = grades[0];
  for (int grade in grades) {
    if (grade &lt; lowest) {
      lowest = grade;
    }
  }
  return lowest;
}

// Procedure 5: Convert to letter grade
String getLetterGrade(double average) {
  if (average &gt;= 90) return 'A';
  if (average &gt;= 80) return 'B';
  if (average &gt;= 70) return 'C';
  if (average &gt;= 60) return 'D';
  return 'F';
}
</code></pre>

<h2 id="procedural-programming-flow">Procedural Programming Flow</h2>
<pre class="codehilite"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            ğŸ“Š PROCEDURAL PROGRAM FLOW ğŸ“Š                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  ğŸ¯ main() â”‚
                    â”‚   (Entry)  â”‚
                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 â”‚                 â”‚
        â–¼                 â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ–¨ï¸ display   â”‚  â”‚ ğŸ§® calculate â”‚  â”‚ ğŸ“ˆ find     â”‚
â”‚   Grades()    â”‚  â”‚   Average()  â”‚  â”‚   Highest() â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚ Print all     â”‚  â”‚ Sum &amp; divide â”‚  â”‚ Compare all â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ ğŸ“ getLetter â”‚
                   â”‚   Grade()    â”‚
                   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
                   â”‚ A, B, C, D, Fâ”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”‘ Key: Each procedure is a reusable unit that:
   âœ“ Performs one specific task
   âœ“ Can be called multiple times
   âœ“ Operates on shared data (grades list)
   âœ“ Returns a result or performs action
</code></pre>

<h3 id="procedural-program-structure">Procedural Program Structure</h3>
<pre class="codehilite"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ—ï¸ PROCEDURAL STRUCTURE ğŸ—ï¸                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main()
  â”‚
  â”œâ”€â–º ğŸ“ Call procedure_1(data)
  â”‚     â”‚
  â”‚     â””â”€â–º âš™ï¸ Process data
  â”‚         â””â”€â–º ğŸ“¤ Return result
  â”‚
  â”œâ”€â–º ğŸ“ Call procedure_2(data)
  â”‚     â”‚
  â”‚     â””â”€â–º âš™ï¸ Process data
  â”‚         â””â”€â–º ğŸ“¤ Return result
  â”‚
  â””â”€â–º ğŸ“ Call procedure_3(data)
        â”‚
        â””â”€â–º âš™ï¸ Process data
            â””â”€â–º ğŸ“¤ Return result

Key Characteristics:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“ Top-down design                          â”‚
â”‚ ğŸ”„ Structured programming                   â”‚
â”‚ ğŸ“Š Data passed between procedures           â”‚
â”‚ ğŸ”§ Procedures are independent units         â”‚
â”‚ â™»ï¸ Code reusability through functions       â”‚
â”‚ ğŸ“ Sequential execution flow                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Real-World Analogy: ğŸ­ Assembly Line
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Station 1â”‚â”€â”€â”€â–ºâ”‚ Station 2â”‚â”€â”€â”€â–ºâ”‚ Station 3â”‚
â”‚   Cut    â”‚    â”‚   Bend   â”‚    â”‚   Weld   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Each station = One procedure with one job
</code></pre>

<h2 id="procedural-vs-oop-comparison">Procedural vs OOP Comparison</h2>
<pre class="codehilite"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘             ğŸ“Š PROCEDURAL PROGRAMMING ğŸ“Š                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                               â•‘
â•‘  ğŸ“¦ Data: [grades list] â—„â”€â”€â”€â”€â”                               â•‘
â•‘                               â”‚                               â•‘
â•‘  âš™ï¸ Procedures:               â”‚ (All procedures access        â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚  the same data)               â•‘
â•‘  â”‚ displayGradesâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                               â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚                               â•‘
â•‘  â”‚ calcAverage  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                               â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚                               â•‘
â•‘  â”‚ findHighest  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â•‘
â•‘                                                               â•‘
â•‘  ğŸ¯ Separation: Data and functions are separate              â•‘
â•‘  ğŸ“Š Structure: Top-down design                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Compare with:

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ›ï¸ OBJECT-ORIENTED ğŸ›ï¸                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â•‘
â•‘  â”‚  ğŸ“š GradeBook (Object)     â”‚                              â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                              â•‘
â•‘  â”‚ ğŸ“¦ Data:                   â”‚                              â•‘
â•‘  â”‚  â€¢ grades: List&lt;int&gt;       â”‚                              â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                              â•‘
â•‘  â”‚ âš™ï¸ Methods:                â”‚                              â•‘
â•‘  â”‚  â€¢ display()               â”‚                              â•‘
â•‘  â”‚  â€¢ calcAverage()           â”‚                              â•‘
â•‘  â”‚  â€¢ findHighest()           â”‚                              â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â•‘
â•‘                                                               â•‘
â•‘  ğŸ¯ Encapsulation: Data and methods bundled together         â•‘
â•‘  ğŸ“¦ Structure: Object-based design                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</code></pre>

<p>Procedural programming provides a natural way to organize sequential tasks into reusable procedures. It's particularly effective for utilities, scripts, and algorithms where data processing follows a clear sequence of steps. While simpler than OOP for small projects, it can become harder to manage as complexity grows, since data and operations on that data are kept separate.</p>
<hr />
<h2 id="further-reading">Further Reading</h2>
<p><strong>Procedural Programming:</strong>
- <a href="https://en.wikipedia.org/wiki/Structured_programming">Structured Programming</a> - Historical context and principles
- <a href="https://dart.dev/guides/language/language-tour#functions">Functions in Dart</a> - Official guide</p>
<p><strong>Code Organization:</strong>
- <a href="https://medium.com/@sheyiogundijo/clean-code-in-a-nutshell-ac7aa5f80a99">Clean Code: Functions</a> - Writing good procedures
- <a href="https://en.wikipedia.org/wiki/Modular_programming">Modular Programming</a> - Organizing code into modules</p>
<p><strong>Related Concepts:</strong>
- <a href="https://www.cs.uic.edu/~jbell/CourseNotes/OO_SoftwareEngineering/TopDownDesign.html">Top-Down Design</a> - Procedural design approach
- <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY Principle</a> - Don't Repeat Yourself</p>
<p><strong>Languages:</strong>
- <a href="https://www.learn-c.org/">C Programming</a> - Classic procedural language
- <a href="https://www.freepascal.org/">Pascal</a> - Structured procedural language</p>
<hr />
<h2 id="about-the-author">ğŸ‘¤ About the Author</h2>
<p><strong>SrÄ‘an LjuÅ¡tina</strong> - Software Developer &amp; Technical Writer</p>
<p>ğŸŒ <a href="https://srdapp.rs">Website</a> | ğŸ’¼ <a href="https://www.linkedin.com/in/srdjanljustina/">LinkedIn</a> | ğŸ’» <a href="https://github.com/projekt">GitHub</a></p>
<hr />
<p><strong>Series Navigation:</strong> <a href="05_declarative_programming.md">â† Declarative Programming</a> | Article 6 of 7 | Next: <a href="07_summary.md">Summary and Best Practices â†’</a></p>
<p><strong>Other Articles in This Series:</strong>
- <a href="01_what_are_programming_paradigms.md">Article 1: What Are Programming Paradigms?</a>
- <a href="02_imperative_programming.md">Article 2: Imperative Programming</a>
- <a href="03_oop.md">Article 3: Object-Oriented Programming (OOP)</a>
- <a href="04_functional_programming.md">Article 4: Functional Programming</a>
- <a href="05_declarative_programming.md">Article 5: Declarative Programming</a>
- <strong>Article 6: Procedural Programming</strong> (Current)
- <a href="07_summary.md">Article 7: Choosing the Right Paradigm - Summary and Best Practices</a></p>