This article was originally published on my website.
For the latest version and more articles, visit: https://projekt.github.io/articles/

---


# Programming Paradigms Series - Article 6: Procedural Programming

**Series Navigation:** [â† Declarative Programming](05_declarative_programming.md) | Article 6 of 7 | Next: [Summary and Best Practices â†’](07_summary.md)

---

**About This Series**

This article series represents my journey of learning and applying fundamental programming concepts to the Dart programming language. These are my detailed notes and insights from the learning process, which I hope will be valuable to others exploring similar topics.

---

## Table of Contents

1. [Concept](#concept)
2. [Real-Life Analogy](#real-life-analogy)
3. [Dart Example](#dart-example)
4. [Procedural Programming Flow](#procedural-programming-flow)
5. [Procedural vs OOP Comparison](#procedural-vs-oop-comparison)

---

## Concept

Procedural programming is a subset of imperative programming where you organize code into procedures (functions) that operate on data. It emphasizes a step-by-step approach but with reusable blocks of code.

## Real-Life Analogy

Think of an assembly line in a factory. Each station (procedure) performs a specific task:
- Station 1: Cut metal
- Station 2: Bend metal
- Station 3: Weld parts
- Station 4: Paint product
- Station 5: Package

Each station is independent but contributes to the final product.

## Dart Example

```dart
// Procedural approach to processing student grades

void main() {
  List<int> grades = [85, 92, 78, 95, 88, 73, 90];

  displayGrades(grades);
  double avg = calculateAverage(grades);
  print('\nAverage grade: ${avg.toStringAsFixed(2)}');

  int highest = findHighest(grades);
  int lowest = findLowest(grades);
  print('Highest: $highest, Lowest: $lowest');

  String letterGrade = getLetterGrade(avg);
  print('Class average letter grade: $letterGrade');
}

// Procedure 1: Display all grades
void displayGrades(List<int> grades) {
  print('Student Grades:');
  for (int i = 0; i < grades.length; i++) {
    print('Student ${i + 1}: ${grades[i]}');
  }
}

// Procedure 2: Calculate average
double calculateAverage(List<int> grades) {
  int sum = 0;
  for (int grade in grades) {
    sum += grade;
  }
  return sum / grades.length;
}

// Procedure 3: Find highest grade
int findHighest(List<int> grades) {
  int highest = grades[0];
  for (int grade in grades) {
    if (grade > highest) {
      highest = grade;
    }
  }
  return highest;
}

// Procedure 4: Find lowest grade
int findLowest(List<int> grades) {
  int lowest = grades[0];
  for (int grade in grades) {
    if (grade < lowest) {
      lowest = grade;
    }
  }
  return lowest;
}

// Procedure 5: Convert to letter grade
String getLetterGrade(double average) {
  if (average >= 90) return 'A';
  if (average >= 80) return 'B';
  if (average >= 70) return 'C';
  if (average >= 60) return 'D';
  return 'F';
}
```

## Procedural Programming Flow

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            ğŸ“Š PROCEDURAL PROGRAM FLOW ğŸ“Š                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  ğŸ¯ main() â”‚
                    â”‚   (Entry)  â”‚
                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 â”‚                 â”‚
        â–¼                 â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ–¨ï¸ display   â”‚  â”‚ ğŸ§® calculate â”‚  â”‚ ğŸ“ˆ find     â”‚
â”‚   Grades()    â”‚  â”‚   Average()  â”‚  â”‚   Highest() â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚ Print all     â”‚  â”‚ Sum & divide â”‚  â”‚ Compare all â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ ğŸ“ getLetter â”‚
                   â”‚   Grade()    â”‚
                   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
                   â”‚ A, B, C, D, Fâ”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”‘ Key: Each procedure is a reusable unit that:
   âœ“ Performs one specific task
   âœ“ Can be called multiple times
   âœ“ Operates on shared data (grades list)
   âœ“ Returns a result or performs action
```

### Procedural Program Structure

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ—ï¸ PROCEDURAL STRUCTURE ğŸ—ï¸                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main()
  â”‚
  â”œâ”€â–º ğŸ“ Call procedure_1(data)
  â”‚     â”‚
  â”‚     â””â”€â–º âš™ï¸ Process data
  â”‚         â””â”€â–º ğŸ“¤ Return result
  â”‚
  â”œâ”€â–º ğŸ“ Call procedure_2(data)
  â”‚     â”‚
  â”‚     â””â”€â–º âš™ï¸ Process data
  â”‚         â””â”€â–º ğŸ“¤ Return result
  â”‚
  â””â”€â–º ğŸ“ Call procedure_3(data)
        â”‚
        â””â”€â–º âš™ï¸ Process data
            â””â”€â–º ğŸ“¤ Return result

Key Characteristics:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“ Top-down design                          â”‚
â”‚ ğŸ”„ Structured programming                   â”‚
â”‚ ğŸ“Š Data passed between procedures           â”‚
â”‚ ğŸ”§ Procedures are independent units         â”‚
â”‚ â™»ï¸ Code reusability through functions       â”‚
â”‚ ğŸ“ Sequential execution flow                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Real-World Analogy: ğŸ­ Assembly Line
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Station 1â”‚â”€â”€â”€â–ºâ”‚ Station 2â”‚â”€â”€â”€â–ºâ”‚ Station 3â”‚
â”‚   Cut    â”‚    â”‚   Bend   â”‚    â”‚   Weld   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Each station = One procedure with one job
```

## Procedural vs OOP Comparison

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘             ğŸ“Š PROCEDURAL PROGRAMMING ğŸ“Š                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                               â•‘
â•‘  ğŸ“¦ Data: [grades list] â—„â”€â”€â”€â”€â”                               â•‘
â•‘                               â”‚                               â•‘
â•‘  âš™ï¸ Procedures:               â”‚ (All procedures access        â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚  the same data)               â•‘
â•‘  â”‚ displayGradesâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                               â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚                               â•‘
â•‘  â”‚ calcAverage  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                               â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚                               â•‘
â•‘  â”‚ findHighest  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â•‘
â•‘                                                               â•‘
â•‘  ğŸ¯ Separation: Data and functions are separate              â•‘
â•‘  ğŸ“Š Structure: Top-down design                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Compare with:

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ›ï¸ OBJECT-ORIENTED ğŸ›ï¸                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â•‘
â•‘  â”‚  ğŸ“š GradeBook (Object)     â”‚                              â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                              â•‘
â•‘  â”‚ ğŸ“¦ Data:                   â”‚                              â•‘
â•‘  â”‚  â€¢ grades: List<int>       â”‚                              â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                              â•‘
â•‘  â”‚ âš™ï¸ Methods:                â”‚                              â•‘
â•‘  â”‚  â€¢ display()               â”‚                              â•‘
â•‘  â”‚  â€¢ calcAverage()           â”‚                              â•‘
â•‘  â”‚  â€¢ findHighest()           â”‚                              â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â•‘
â•‘                                                               â•‘
â•‘  ğŸ¯ Encapsulation: Data and methods bundled together         â•‘
â•‘  ğŸ“¦ Structure: Object-based design                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

Procedural programming provides a natural way to organize sequential tasks into reusable procedures. It's particularly effective for utilities, scripts, and algorithms where data processing follows a clear sequence of steps. While simpler than OOP for small projects, it can become harder to manage as complexity grows, since data and operations on that data are kept separate.

---

## Further Reading

**Procedural Programming:**
- [Structured Programming](https://en.wikipedia.org/wiki/Structured_programming) - Historical context and principles
- [Functions in Dart](https://dart.dev/guides/language/language-tour#functions) - Official guide

**Code Organization:**
- [Clean Code: Functions](https://medium.com/@sheyiogundijo/clean-code-in-a-nutshell-ac7aa5f80a99) - Writing good procedures
- [Modular Programming](https://en.wikipedia.org/wiki/Modular_programming) - Organizing code into modules

**Related Concepts:**
- [Top-Down Design](https://www.cs.uic.edu/~jbell/CourseNotes/OO_SoftwareEngineering/TopDownDesign.html) - Procedural design approach
- [DRY Principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) - Don't Repeat Yourself

**Languages:**
- [C Programming](https://www.learn-c.org/) - Classic procedural language
- [Pascal](https://www.freepascal.org/) - Structured procedural language

---

## ğŸ‘¤ About the Author

**SrÄ‘an LjuÅ¡tina** - Software Developer & Technical Writer

ğŸŒ [Website](https://srdapp.rs) | ğŸ’¼ [LinkedIn](https://www.linkedin.com/in/srdjanljustina/) | ğŸ’» [GitHub](https://github.com/projekt)

---

**Series Navigation:** [â† Declarative Programming](05_declarative_programming.md) | Article 6 of 7 | Next: [Summary and Best Practices â†’](07_summary.md)

**Other Articles in This Series:**
- [Article 1: What Are Programming Paradigms?](01_what_are_programming_paradigms.md)
- [Article 2: Imperative Programming](02_imperative_programming.md)
- [Article 3: Object-Oriented Programming (OOP)](03_oop.md)
- [Article 4: Functional Programming](04_functional_programming.md)
- [Article 5: Declarative Programming](05_declarative_programming.md)
- **Article 6: Procedural Programming** (Current)
- [Article 7: Choosing the Right Paradigm - Summary and Best Practices](07_summary.md)
