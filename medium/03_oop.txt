This article was originally published on my website.
For the latest version and more articles, visit: https://projekt.github.io/articles/

---


# Programming Paradigms Series - Article 3: Object-Oriented Programming (OOP)

**Series Navigation:** [â† Imperative Programming](02_imperative_programming.md) | Article 3 of 7 | Next: [Functional Programming â†’](04_functional_programming.md)

---

**About This Series**

This article series represents my journey of learning and applying fundamental programming concepts to the Dart programming language. These are my detailed notes and insights from the learning process, which I hope will be valuable to others exploring similar topics.

---

## Table of Contents

1. [Concept](#concept)
2. [Real-Life Analogy](#real-life-analogy)
3. [Dart Example](#dart-example)
4. [OOP Class Hierarchy Diagram](#oop-class-hierarchy-diagram)
5. [OOP Core Principles](#oop-core-principles)

---

## Concept

Object-Oriented Programming organizes code around objects that bundle data (properties) and behavior (methods) together. It's based on concepts like encapsulation, inheritance, and polymorphism.

## Real-Life Analogy

Think of a car manufacturing plant. Each car is an object with:
- **Properties**: color, model, speed, fuel level
- **Methods**: accelerate(), brake(), refuel()
- **Encapsulation**: The driver doesn't need to know how the engine works internally
- **Inheritance**: A SportsCar inherits features from Car but adds turbo boost
- **Polymorphism**: Both Car and Motorcycle can move(), but they do it differently

## Dart Example

```dart
// Base class
class Vehicle {
  String brand;
  int speed;

  Vehicle(this.brand, this.speed);

  void move() {
    print('$brand is moving at $speed km/h');
  }

  void stop() {
    speed = 0;
    print('$brand has stopped');
  }
}

// Inheritance
class Car extends Vehicle {
  int numberOfDoors;

  Car(String brand, int speed, this.numberOfDoors) : super(brand, speed);

  // Method overriding (Polymorphism)
  @override
  void move() {
    print('$brand car with $numberOfDoors doors is driving at $speed km/h');
  }

  void honk() {
    print('Beep beep!');
  }
}

class Motorcycle extends Vehicle {
  bool hasSidecar;

  Motorcycle(String brand, int speed, this.hasSidecar) : super(brand, speed);

  @override
  void move() {
    String sidecarInfo = hasSidecar ? 'with sidecar' : 'without sidecar';
    print('$brand motorcycle $sidecarInfo is riding at $speed km/h');
  }
}

void main() {
  Car myCar = Car('Toyota', 80, 4);
  Motorcycle myBike = Motorcycle('Harley', 100, false);

  myCar.move();      // Toyota car with 4 doors is driving at 80 km/h
  myCar.honk();      // Beep beep!
  myBike.move();     // Harley motorcycle without sidecar is riding at 100 km/h

  // Polymorphism in action
  List<Vehicle> vehicles = [myCar, myBike];
  for (var vehicle in vehicles) {
    vehicle.move();  // Each calls its own version of move()
  }
}
```

## OOP Class Hierarchy Diagram

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ›ï¸ OOP CLASS HIERARCHY ğŸ›ï¸                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    ğŸš— Vehicle           â”‚
                    â”‚  (Parent/Base Class)    â”‚
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
                    â”‚ ğŸ“¦ PROPERTIES:          â”‚
                    â”‚   â€¢ brand: String       â”‚
                    â”‚   â€¢ speed: int          â”‚
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
                    â”‚ âš™ï¸ METHODS:             â”‚
                    â”‚   â€¢ move(): void        â”‚
                    â”‚   â€¢ stop(): void        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    ğŸ”— INHERITANCE     â”‚
                    â”‚      (extends)        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   ğŸš™ Car         â”‚          â”‚  ğŸï¸ Motorcycle   â”‚
        â”‚  (Child Class)   â”‚          â”‚  (Child Class)   â”‚
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
        â”‚ ğŸ“¦ PROPERTIES:   â”‚          â”‚ ğŸ“¦ PROPERTIES:   â”‚
        â”‚  â€¢ numberOfDoors â”‚          â”‚  â€¢ hasSidecar    â”‚
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
        â”‚ âš™ï¸ METHODS:      â”‚          â”‚ âš™ï¸ METHODS:      â”‚
        â”‚  â€¢ move() âœ¨     â”‚          â”‚  â€¢ move() âœ¨     â”‚
        â”‚  â€¢ honk()        â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   âœ¨ = Polymorphism: Same method name, different implementation
```

## OOP Core Principles

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                ğŸ¯ OOP FOUR PILLARS ğŸ¯                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ 1ï¸âƒ£ ENCAPSULATION ğŸ“¦   â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  Bundle data and methods
   â”‚   â”‚ ğŸ”’ Private  â”‚   â”‚  Hide internal details
   â”‚   â”‚    Data     â”‚   â”‚  Show only what's needed
   â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚
   â”‚          â”‚          â”‚
   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”‚
   â”‚   â”‚ ğŸ”“ Public   â”‚   â”‚
   â”‚   â”‚   Methods   â”‚   â”‚  â† External access point
   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ 2ï¸âƒ£ INHERITANCE ğŸ§¬      â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
        ğŸ‘¨ Parent Class
        â†“ (DNA passed down)
        â”œâ”€â”€â–º ğŸ‘¦ Child 1 (inherits properties)
        â”‚
        â””â”€â”€â–º ğŸ‘§ Child 2 (inherits properties)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ 3ï¸âƒ£ POLYMORPHISM ğŸ­     â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
   Same Interface â†’ Different Implementations

   vehicle.move()
        â”œâ”€â–º Car.move()        â†’ ğŸš— "Driving..."
        â””â”€â–º Motorcycle.move() â†’ ğŸï¸ "Riding..."

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ 4ï¸âƒ£ ABSTRACTION ğŸ¨      â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
   User sees:  drive() ğŸš—
              â†“ (Simple interface)
   Hidden:    âš™ï¸ Engine
              ğŸ”§ Transmission
              â›½ Fuel injection
              ğŸ”© Internal mechanics
```

Object-Oriented Programming excels at modeling complex systems with many interrelated components. By organizing code around objects that represent real-world entities, OOP makes large codebases more maintainable, reusable, and easier to understand.

---

## Further Reading

**Object-Oriented Programming:**
- [Object-Oriented Programming in Dart](https://dart.dev/guides/language/language-tour#classes) - Official documentation
- [Design Patterns](https://refactoring.guru/design-patterns) - Gang of Four patterns explained
- [SOLID Principles](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design) - OOP best practices

**Dart OOP Features:**
- [Mixins in Dart](https://dart.dev/guides/language/language-tour#adding-features-to-a-class-mixins) - Code reuse technique
- [Extension Methods](https://dart.dev/guides/language/extension-methods) - Extending existing classes

**Books:**
- [Head First Design Patterns](https://www.oreilly.com/library/view/head-first-design/0596007124/) - Beginner-friendly approach
- [Clean Code](https://www.oreilly.com/library/view/clean-code-a/9780136083238/) - Robert C. Martin

---

## ğŸ‘¤ About the Author

**SrÄ‘an LjuÅ¡tina** - Software Developer & Technical Writer

ğŸŒ [Website](https://srdapp.rs) | ğŸ’¼ [LinkedIn](https://www.linkedin.com/in/srdjanljustina/) | ğŸ’» [GitHub](https://github.com/projekt)

---

**Series Navigation:** [â† Imperative Programming](02_imperative_programming.md) | Article 3 of 7 | Next: [Functional Programming â†’](04_functional_programming.md)

**Other Articles in This Series:**
- [Article 1: What Are Programming Paradigms?](01_what_are_programming_paradigms.md)
- [Article 2: Imperative Programming](02_imperative_programming.md)
- **Article 3: Object-Oriented Programming (OOP)** (Current)
- [Article 4: Functional Programming](04_functional_programming.md)
- [Article 5: Declarative Programming](05_declarative_programming.md)
- [Article 6: Procedural Programming](06_procedural_programming.md)
- [Article 7: Choosing the Right Paradigm - Summary and Best Practices](07_summary.md)
